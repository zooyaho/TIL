# 자료구조와 메모리 구조 이해하기

> 프로그래밍에서 자료구조는 데이터를 효율적으로 저장하고 관리하기 위한 방법이나 형식을 의미합니다. 데이터가 효율적으로 관리되어야 하는 이유는 실제로 프로그램이 실행되는 메모리 자원이 한정되어 있기 때문입니다. 이 포스트에서는 자료구조의 필요성과 메모리 구조, 그리고 자바스크립트의 메모리 관리에 대해 살펴보겠습니다.

## 자료구조란 무엇인가?

> 자료구조는 데이터를 효과적으로 저장하고 검색하는 방법입니다. 예를 들어, 리스트, 스택, 큐, 트리, 그래프 등 여러 종류의 자료구조가 있으며, 각 자료구조는 특정 상황에서 더 효율적으로 작동합니다.

## 자료구조의 필요성

- 메모리 자원의 한정성: 컴퓨터의 메모리는 유한하므로, 프로그램이 데이터를 처리하는 방식에 따라 메모리 자원을 더 효율적으로 사용할 수 있습니다.

- 성능 최적화: 적절한 자료구조를 사용하면 데이터의 접근 속도를 높일 수 있습니다. 예를 들어, 배열에 비해 해시 테이블은 데이터를 검색하는 데 더 빠른 성능을 제공합니다.

## 비트와 바이트

- 비트: 1bit는 0 또는 1의 값을 가질 수 있는 가장 작은 단위입니다.
- 바이트: 1바이트는 8비트로 구성됩니다. 즉, 1byte = 8bit입니다. - - 바이트는 데이터의 크기를 나타내는 기본 단위로 사용됩니다.

## 2진법과 16진법

- 2진법: 컴퓨터의 기계어는 2진법(0과 1)으로 저장됩니다. 각 비트는 0 또는 1로 표현됩니다.
- 16진법: 컴퓨터가 처리하는 데이터의 양을 줄이기 위해 16진법이 사용됩니다. 예를 들어, 색상 코드(Hex color code)는 16진법으로 표현됩니다.

## 메모리 구조

메모리는 여러 영역으로 나뉘어 있으며, 각 영역은 특정한 용도로 사용됩니다.

### 스택(Stack)

LIFO(Last In First Out) 구조로, 가장 최근에 추가된 데이터가 가장 먼저 제거됩니다.

- 사용 예시: 브라우저의 뒤로가기(history) 기능에서 이전 경로를 스택에 저장하고 뒤로가기 버튼을 클릭할 때 가장 최근 경로를 제거합니다.
- 특징: 중간 데이터 접근이 어렵고, 구현이 간단하며 빠릅니다.

### 힙(Heap)

동적 할당 영역으로, 런타임에 필요한 메모리를 동적으로 할당합니다.
주로 객체와 배열 등의 동적 데이터 구조가 저장됩니다.

### 데이터(Data)

전역변수 및 정적변수 영역으로, 프로그램 실행 시 메모리에 고정된 데이터가 저장됩니다.

### 코드(Code)

프로그램의 실행 코드가 저장되는 영역입니다.

## 이벤트 루프에서의 큐와 스택

### Callback Queue

자바스크립트의 비동기 처리를 위한 큐는 다음과 같은 구성 요소로 이루어져 있습니다.

- Macro Task Queue: 일반적인 태스크 큐로, setTimeout, setInterval, DOM 이벤트 처리 등이 포함됩니다.
- Micro Task Queue: Promise의 콜백, MutationObserver API, async/await 함수가 포함됩니다.
- Animation Frame Queue: 브라우저의 렌더링 역할을 하며, 화면을 업데이트하기 위한 작업이 대기합니다.

이벤트 루프는 콜 스택이 비어 있을 때 마이크로 태스크 큐의 모든 작업을 처리합니다. 마이크로 태스크 큐가 비워질 때까지 다른 작업은 수행되지 않으며, 이후 매크로 태스크 큐에서 하나의 작업만 처리합니다.

### Call Stack (Execution Context Stack)

콜 스택은 프로그램의 함수 호출 정보를 추적하고 관리하는 역할을 합니다. 자바스크립트 엔진은 전역 실행 컨텍스트와 함수 실행 컨텍스트를 사용하여 각 스택을 쌓습니다.

- 전역 코드(Global Code): 전역에 존재하는 코드이며, 함수나 클래스의 내부 코드는 포함되지 않습니다.
- 함수 코드(Function Code): 함수 내부에 존재하는 코드로, 중첩된 함수나 클래스의 내부 코드는 포함되지 않습니다.

## JavaScript Engine의 동작 방식

- 소스코드 평가: 코드의 시작부터 끝까지 확인하여 변수를 선언하고 식별자를 생성합니다.
- 소스코드 실행: 선언문을 제외한 나머지 코드를 실행합니다.

## 호이스팅 (Hoisting)

호이스팅은 변수나 함수 선언문이 스코프의 최상단으로 끌려오듯 동작하는 현상입니다. 변수 선언이 최상단에서 실행되는 것처럼 보이게 됩니다.

```javascript
console.log(challenger); // undefined 출력
var challenger = "hello";
```

## Execution Context Stack (실행 컨텍스트 스택)

실행 컨텍스트는 전역 실행 컨텍스트와 함수 단위 실행 컨텍스트로 나뉘며, 실행 컨텍스트가 스택에 쌓입니다. 코드 평가 시 전역 실행 컨텍스트가 스택에 쌓이고, 런타임 환경에서는 함수별 실행 컨텍스트가 스택에 쌓입니다.

## Scope Chaining (스코프 체이닝)

스코프 체이닝은 함수가 다른 함수의 변수를 참조하는 과정에서 발생합니다. 호출한 함수의 어휘적 범위 내에서 가장 가까운 변수를 참조하는 방식으로, 이전 실행 컨텍스트의 주소값을 타고 올라가서 값을 참조합니다.

## 클로저 (Closure)

클로저는 함수가 생성될 때의 환경을 기억하는 특성을 가진 함수입니다. 클로저를 사용하면 내부 함수가 외부 함수의 변수를 참조할 수 있습니다.

```javascript
function test() {
  const title = "hello";

  function displayTitle() {
    console.log(title);
  }

  return displayTitle;
}

const myFunc = test();
myFunc(); // "hello" 출력
```

## 가비지 컬렉터 (Garbage Collector, GC)

자바스크립트는 개발자가 메모리를 직접 관리할 필요가 없는 고수준 언어입니다. GC는 사용하지 않는 데이터를 메모리에서 해제하여 메모리를 효율적으로 관리합니다. 사용하지 않는 데이터의 기준은 더 이상 참조되고 있지 않는 것입니다.

## 순환 참조

순환 참조는 두 객체가 서로를 참조하는 상황입니다. 이 경우 GC는 두 객체가 서로를 참조하고 있기 때문에 메모리를 해제하지 못하게 됩니다.

```javascript
function test() {
  let first = {};
  let second = {};

  first.a = second;
  second.a = first;

  return;
}

test(); // 메모리에서 해제되지 않음
```

최신 GC는 도달 가능한 곳에 참조하는지를 확인하여 메모리를 효율적으로 관리합니다.
